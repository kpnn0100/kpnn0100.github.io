[{"content":" A. Các lý thuyết Trước khi đến với plugin của mình, chúng ta cần hiểu các khái niệm vật lý cơ bản để rõ hơn tác dụng của plugin này.\nI. Cách chúng ta định hướng âm thanh 1. Interaural Time Difference/Chênh lệch thời gian tiếp nhận Chúng ta có 2 tai, được đặt ở 2 vị trí cách nhau. Điều này khiến cho cách chúng ta tiếp nhận một nguồn âm là khác nhau ở mỗi bên tai.\nVới các nguồn âm ở bên phải chúng ta, tai phải sẽ tiếp nhận dao động âm thanh sớm hơn so với tai trái. Điều ngược lại sẽ xảy ra với các nguồn âm bên trái.\nĐộ chênh lệch đó có thể được diễn giải bằng phương trình sau:\n$$ \\Delta t = \\frac{|d_l-d_r|}{c} $$\ntrong đó\n$d_l$ : khoảng cách từ nguồn âm đến tai trái\n$d_r$ : khoảng cách từ nguồn âm đến tai phải\n$c$ : hằng số tốc độ âm thanh trong môi trường, $c = 343 \\frac{m}{s}$ trong điều kiện tự nhiên\n2. Interaural Level Difference/Chênh lệch âm lượng tiếp nhận Nhờ vào cấu tạo đầu của chúng ta và vị trí phân bổ 2 tai, các vùng bị che khuất bởi đầu của mình sẽ có chênh lệch về biên độ dao động, một phần dao động từ nguồn âm đã bị đầu chúng ta \u0026ldquo;ăn\u0026rdquo; mất. Chúng ta sẽ cùng xem hình sau để dễ hình dung về cả 2 sự chênh lệch này.\n3. Stimulus Spectrum/Sự thay đổi về tần số Hãy đặt trước mặt 1 nguồn phát âm thanh, có thể là một cái loa hay một cái quạt. Từ từ cúi đầu xuống và ngửa đầu lên trong khi cổ vẫn hướng về phía nguồn âm, ta sẽ thấy được một sự khác biệt ko đến từ việc chênh lệch tiếp nhận giữa 2 bên tai mà đến từ chính âm sắc của nguồn âm.\nCấu tạo của tai rất phức tạp dẫn đến các cộng hưởng về tần số của âm thanh sẽ khác nhau đối với các hướng tiếp nhận âm thanh khác nhau.\nĐối với các nguồn âm trước mặt, âm thanh dường như có vẻ rõ nét hơn.\nII. Đường đi của âm thanh trong căn phòng Các bạn có thể đọc bài viết của mình về dự án \u0026ldquo;Reflection Calculator\u0026rdquo; để hiểu rõ hơn vấn đề này. Ở đây mình sẽ chỉ tóm tắt.\n1. Sự phản xạ âm Ngoài âm thanh trực tiếp đi đến tai, chúng ta còn có các nguồn âm phụ được tạo ra bởi chính nguồn âm chính, có thời gian đến tai mình cũng như biên độ khác với nguồn âm chính.\n2. Sự định hướng của phản xạ âm Và cũng không ngoại lệ, những âm thanh phản xạ cũng có các đặc tính giống như nguồn âm gốc ban đầu, qua đó chúng ta có thể xác định được âm thanh phản xạ ở vị trí nào.\nVới một căn phòng hình dạng bình thường, chúng ta sẽ có 6 phản xạ đầu có âm lượng lớn nhất đến từ 6 mặt của căn phòng.\nVà các phản xạ sau đó, chúng ta có thể coi như đó là âm vang (reverb)\nB. True Position - Một plugin được phát triển bởi mình I. Tại sao mình làm plugin này Bản thân mình là một người viết nhạc, một người hòa âm và một người phối khí. Trong quá trình sáng tác, hoàn thiện các tác phẩm âm nhạc, mình nhận ra một thao tác mình lặp lại rất nhiều lần nhưng ko đạt được độ hiệu quả cao do mình ko có đủ thời gian để tập trung vào một vấn đề quá nhiều.\nVấn đề đó chính là tạo không gian cho âm thanh. Một cây guitar ở bên trái 30 độ, một cây violin ở bên phải 45 độ hay một cây piano ở trước mặt mình. Cách nhanh nhất và phổ biến nhất mọi người hay dùng để tạo ra không gian trong âm thanh chính là lệch đi biên độ dao động của 2 bên tai, tạo ra một sự chênh lệch 2 bên tai cho 1 nguồn âm.\nNhưng cách này lại không đem đến được sự chính xác, nhất là khi nguồn âm di chuyển, chúng ta có thể nhận ra rõ ràng vấn đề của phương pháp này, âm thanh có vẻ như đang đi xuyên qua đầu mình, chứ ko phải đi ngang qua trước mặt như cách mà nó phải xảy ra. Hãy thử tưởng tượng một ca sĩ đi xuyên qua đầu mình, chỉ nghĩ đến thôi đã thấy rợn người.\nCách mình hay sử dụng đó là dùng một plugin khác có sẵn hoặc dùng chính các tính năng của DAW để tạo ra sự chênh lệch về thời gian của âm thanh, kết hợp với chênh lệch về biên độ để tạo ra một không gian chính xác nhất.\nNHƯNG\nTất nhiên là sẽ có một bất cập nào đấy khiến mình phải bỏ công viết plugin này. Bỏ qua các yếu tố cá nhân như muốn thể hiện bản thân ở lĩnh vực này. Rất khó để có thể kiểm soát những thành phần của bản nhạc chỉ việc thay đổi chênh lệch về thời gian, khi số lượng nhạc cụ đã đạt tới con số 10 15, mình không thể biết được cây piano đầu tiên mình đã đặt nó ở vị trí nào, chỉ dùng tai để nghe không thể xác định chính xác được. Điều này có thể gây nên những xung đột về không gian, chẳng hạn như guitar và vocal bè ở chung 1 vị trí (Nếu điều này xảy ra trong thực tế nghĩa là vocal bè ngồi lên đầu guitar :\u0026gt; rất là dị), nhưng rất khó để xác định được vấn đề đến từ 2 cái thằng này vì giới hạn của tai người.\n  Ngoài ra, rất là phức tạp để có thể tạo được thông số delay đúng với thực tế ở trong 1 căn phòng, gần như cách mình sử dụng chỉ là chọn thời gian chênh lệch giữa các lần delay bằng với một phách hay nửa phách, để cho dù nó có sai với thực tế thì nó vẫn phù hợp với tính nhạc. Vì thế mình quyết định viết 1 cái plugin có giao diện trực quan để kiểm soát những thành phần này tốt hơn.\nII. Ý tưởng ban đầu \u0026ldquo;Nó sẽ chỉ cần 1 cái kéo thả tương ứng với vị trí nguồn phát\u0026rdquo; - mình nghĩ\nGiao diện đó phải là một cái gì đấy khác với các plugin thông thường, nơi mà mọi thứ được thể hiện bằng số giống với các đồ analog ngày xưa. Giao diện đó phải trực quan và dễ sử dụng, càng ít sự tương tác càng tốt, nhưng ko được bỏ qua những thông số quan trọng.\nXong phần giao diện, thuật toán là cái rất quan trọng với 1 plugin, một thuật toán dở có thể làm plugin bị trôi vào dĩ vãng. Làm sao để tạo ra sự chênh lệch về thời gian?\nPhải chăng chỉ cần giữ lại những sample của quá khứ và phát nó lại ở một thời điểm mình đã tính ra được dựa vào những công thức vốn có thì chúng ta sẽ có một phần trình diễn hoàn hảo đến từ các con số thập phân dấu phẩy động.\nNhưng không đơn giản vậy, hiệu năng là một thứ rất đáng lưu ý đối với real time digital signal processing (Xử lý tín hiệu thời gian thực).\nLàm sao để chúng ta có thể liên tục ghi những sample mới đồng thời biết chính xác địa chỉ cần truy cập của sample cũ. Việc giữ cho mảng của chúng ta luôn có sample mới nhất nằm ở phần từ 0 của mảng sẽ rất tốn hiệu năng của máy tính vì nó phải liên tục làm mới mảng để đưa ra được vị trí đúng cho từng phần tử.\nMột giải pháp đó chính là mảng liên kết, bằng cách liên tục chèn phần tử mới vào đầu mảng, chúng ta sẽ luôn có một thứ tự đúng của mỗi phần tử, phần tử đầu tiên là sample vừa mới được tiếp nhận, và phần tử cuối cùng là phần tử \u0026ldquo;già\u0026rdquo; nhất của mảng.\nvẫn là một cái NHƯNG\nViệc truy cập vào một phần tử cụ thể xảy ra liên tục nên dùng mảng liên kết sẽ ko thể tối ưu được chuyện này vì muốn truy cập vào phần tử của mảng liên kết, bắt buộc phải duyệt qua từng phần tử cho đến phần tử cần tìm. Hàng trăm, hàng nghìn lệnh so sánh ko cần thiết sẽ là một thất bại cho dự án này.\nVậy thì kết hợp 2 cái lại\nChúng ta tạo ra mảng liên kết của riêng mình. Bằng cách dùng 1 biến để lưu giá trị tương ứng với địa chỉ của phần tử đầu chúng ta có thể thích nghi được với sự làm mới liên tục của dữ liệu âm thanh.\nChúng ta sẽ cùng lúc, ghi đè dữ liệu mới vào địa chỉ mà chúng ta đang đánh dấu là địa chỉ của cái đầu và cập nhật địa chỉ tiếp theo. Điều này đỏi hỏi số lượng phần tử của mảng phải là một hằng số\n1 2 3 4 5 6 7 8  for (int sample = 0; sample \u0026lt; numSamples; sample++) { PastSample[head] = bufferLChannel[sample]; head += 1; if (head == maxdelaysample) { head = 0; } }   Đã có được sự chênh lệch về âm thanh cơ bản, chúng ta sẽ tạo ra chênh lệch về biên độ. Điều này thậm chí còn đơn giản hơn khi mà chỉ cần cho rằng chênh lệch biên độ tỉ lệ thuận với chênh lệch thời gian.\nVà ta đã xong phần định hướng âm, vậy còn phần tạo ra các phản xạ âm trong phòng.\nVẫn rất là đơn giản, chúng ta sẽ sử dụng hình học cơ bản để tìm ra các điểm phản xạ âm mà tiếp xúc đến tai người nghe.\nIII. Thực nghiệm Đây là giao diện sử dụng của plugin:\nChấm màu đen là vị trí của người nghe\nChấm trắng có thể kéo thả, là vị trí của nguồn phát sẽ liên kết với slider Position X, Position Y\nRoom Length: kích thước phòng theo chiều ngang\nRoom Width: kích thước phòng theo chiều dọc\nRoom Heigh: kích thước phòng theo chiều cao\nDry: Độ lớn của âm thanh trực tiếp\nWet: độ lớn của những âm thanh phản xạ\nHãy cùng so sánh phương pháp thông thường và phương pháp sử dụng plugin của mình (Nhớ đeo tai nghe nhé)\nCách panning thông thường:\n  Dùng plugin của mình vặn tham số x:\n  Âm thanh giới thiệu:\n  Hiện tại các bạn có thể dùng thử phiên bản đầu tiên của Plugin này tại đây:\nhttps://github.com/kpnn0100/TruePosition\n","date":"2022-08-03T00:00:00Z","image":"https://kpnn0100.github.io/p/true-position-vst3-plugin-gi%E1%BA%A3-l%E1%BA%ADp-v%E1%BB%8B-tr%C3%AD-%C3%A2m-thanh-trong-ph%C3%B2ng/TruePosition_hu9fe1dacd5be6627572d653b2f851a4b3_221160_120x120_fill_box_smart1_3.png","permalink":"https://kpnn0100.github.io/p/true-position-vst3-plugin-gi%E1%BA%A3-l%E1%BA%ADp-v%E1%BB%8B-tr%C3%AD-%C3%A2m-thanh-trong-ph%C3%B2ng/","title":"True Position: VST3 Plugin giả lập vị trí âm thanh trong phòng"},{"content":" Nhận diện và trích xuất phần khuyết tật của quả xoài là một bài toán quan trọng phục vụ trong việc tự động hóa quá trình sản xuất. Bài viết này sẽ trình bày về việc hiện thực hóa các thuật toán xử lý ảnh cùng với đó là tạo ra dữ liệu để training cũng như sử dụng model U-net để nhận diện những điểm ảnh thuộc quả xoài và phần khuyết tật của quả xoài.\nGiới thiệu Mô hình này sẽ gồm 2 giai đoạn chính đó là Image Segmentation nhận diện vùng chứa quả xoài và Image Segmentation nhận diện vùng chứa phần khuyết tật. Với đầu vào là một bức ảnh bất kỳ chứa quả xoài, mô hình này sẽ nhận diện vùng chứa quả xoài dưới dạng binary image. Tiếp đó, mô hình sẽ phải đưa ra được những vùng được đánh giá là khuyết tật ở trong mask của binary image đã được nhận diện ở trên và tính toán ra tỉ lệ phần trăm so với vùng chứa quả xoài. Tôi đề xuất sử dụng kiến trúc mạng U-net để thực hiện giai đoạn 1 và thuật toán xử lý ảnh binary threshold cải tiến để thực hiện giai đoạn 2.\nGiai đoạn Image Segmentation sử dụng CNN Convolutional Neural Networks là một loại Thuật toán Deep learning lấy hình ảnh làm đầu vào và tìm hiểu các tính năng khác nhau của hình ảnh thông qua các bộ lọc. Điều này cho phép họ tìm hiểu các đối tượng quan trọng có trong hình ảnh, cho phép họ phân biệt hình ảnh này với hình ảnh kia.\nCNN có hiệu suất tương tự như các Neuron Network được kết nối đầy đủ thông thường. Các CNN này có các trọng số có thể học hỏi từ đầu vào và độ chệch. Mọi nơ-ron được kết nối trong mạng đều nhận được đầu vào và thực hiện một sản phẩm chấm trên đó. Điều này tiến hành theo kiểu phi tuyến tính. Có một chức năng điểm số có thể phân biệt ở cuối. Hàm này bao gồm các điểm số mà chúng ta thu được từ các lớp khác nhau của mạng nơ-ron. Cuối cùng, một hàm mất mát ở cuối để đánh giá hiệu suất của mô hình. Mạng nơ-ron tích chập khác với Mạng nơ-ron tiêu chuẩn ở chỗ có một giả định rõ ràng về đầu vào là một hình ảnh.\nU-net Toàn bộ kiến trúc không hề sử dụng một lớp fully connected nào. Các mô hình end-to-end thông thường, lớp kế cuối của mạng sẽ là các lớp fully connected để kết nối các đặc trưng đã phân tích được nhằm đưa ra kết quả dự đoán. Tuy nhiên, ở kiến trúc U-net, việc kết nối các đặc trưng sẽ do nửa thứ 2 của \u0026ldquo;chữ U\u0026rdquo; đảm nhận, điều này giúp mạng không cần mạng fully connected, do đó có thể chấp nhận input với kích thước bất kì.\nU-net sử dụng Phương pháp đệm (Padding method), điều này giúp kiến trúc có thể phân đoạn hình ảnh được hoàn toàn. Phương pháp này đặc biệt quan trọng khi segment cho các hình ảnh, nếu không, độ phân giải có thể bị hạn chế bởi dung lượng của bộ nhớ GPU.\nĐối với bài toán Segmentation, hệ đo được sử dụng là IOU (Intersection over Union). Hệ đo này cho thấy tỉ lệ phần diện tích giao so với phần diện tích liên hiệp. Hệ đo này có phương trình như sau: $$ IoU=\\frac{|A\\cap{B}|}{|A\\cup{B}|} $$\nTrong đó $A$ diện tích vùng mà model nhận diện, $B$ là vùng thực tế.\nInput của model sẽ là ảnh màu có kích thước $128x128x3$ và output là ảnh trắng đen có kích thước 128x128x1, tổng params: 6,667,639, params có thể train: 6,667,639, params không thể train: 0\nTìm kiếm data Sử dụng 2 dataset 1 là hình ảnh những quả xoài bình thường không dị tật:\n https://www.kaggle.com/code/agbajeabdullateef/mango-disease-classification/notebook 2 là hình ảnh những quả xoài khuyết tật xen kẽ(\\ref{fig:xoaikhuyetat}): https://data.mendeley.com/datasets/fmfncxjz3v/1 Tất cả hình ảnh đều có dạng background trắng xám và quả xoài nằm ở trung tâm, kích thước không đồng bộ.   Data thô của quả xoài khuyết tật\nKhởi tạo dataset Vì background có dạng đơn giản nên chúng ta có thể dùng thuần xử lý ảnh để lọc ra những pixel chứa quả xoài. Đầu tiên là trích xuất các đặc trưng về màu. Chuyển tất cả ảnh về hệ màu HSV (Hue, Satuaration, Value).Lấy một vài ảnh để đo thông số HSV nhận thấy: background có thông số xấp xỉ (0,0,218) và phần chứa xoài xấp xỉ (35,192,146). Chúng ta sẽ chỉ quan tâm đến 2 giá trị Satuaration và Value vì dataset có nhiều loại xoài với nhiều màu khác nhau, thông số Hue sẽ ko đáng tin cậy. Ý tưởng ban đầu là tìm trung bình các thông số trên của ảnh và tiến hành lọc ra những pixel khác với trung bình (lớn hơn thì là vùng chứa xoài, bé hơn thì là background) với các hằng số bias và hệ số sàn với từng giá trị. Từ đó có thể hình thành phương trình như sau:\n$$ o(x,y)= 255 \\text{ if } f(x,y)\u0026gt;b $$\n$$ o(x,y)= 0 \\text{ else} $$\n(1)\nVới $o(x,y)$ là pixel có tọa độ $(x,y)$ của ảnh đầu ra\n$f(x,y)$ là giá trị tính toán pixel có tọa độ $(x,y)$ của ảnh đầu vào có công thức $$ f(x,y)=h(x,y)\\times C_h+s(x,y)\\times C_s+v(x,y)\\times C_v $$\n$h(x,y),s(x,y),v(x,y)$ giá trị hsv tại pixel có tọa độ $(x,y)$\n$C_h,C_s,C_v$ là hằng số bias $$ b=((m_h+fl_h)\\times C_h+(m_s+fl_s)\\times C_s+(m_a+fl_v)\\times C_v)\\times b_G $$\nKết quả thu được sẽ có dạng như hình\nData Augmentation Vì các background có dạng quá đơn giản nên kết quả train sẽ bị khóa cố định trong 1 vài trường hợp background cụ thể model mới hoạt động tốt được, nên cần thiết phải tăng cường dữ liệu bằng cách thay thế các background đơn bằng background phức tạp. Ở đây, ta chọn các background có độ chi tiết cao như ở ngoài vườn cây.\nDataset cuối cùng sẽ có dạng như hình\n### Training Chúng ta sẽ dùng biến thiên tốc độ học để điều chỉnh khi gần tới cực tiểu của model và save model sau mỗi epoch dưới tên ‘model.h5’ Kết quả training, IoU trung bình đạt 0.7066\nGiai đoạn Image Segmentation dùng Digital Image Processing Tổng quan Sau khi chúng ta đã lọc ra được những pixel của quả xoài bằng model U-net, chúng ta tiến hành lọc ra những phần khuyết tật. Bằng mắt thường chúng ta dễ dàng nhận ra phần khuyết tật là phần có màu sẫm hơn bình thường, thậm chí là màu đen nâu, vậy cơ chế chúng ta đưa ra sẽ làm tìm những vùng đó bằng thuật toán tìm trung bình như (1).\\\nTiền xử lý dữ liệu vào Để đạt được kết quả tốt nhất, chúng ta phải loại bỏ đi những thứ khiến thuật toán trung bình bị sai lệch, đầu tiên là đổ bóng của hình, chúng ta sẽ hạn chế việc một bên tối và một bên sáng do ánh sáng chiếu từ một hướng trên quả xoài bằng cách nâng sáng những vùng tối và giảm sáng những vùng sáng, ở đây tác giả sử dụng thuật toán của HViktorTsoi(https://gist.github.com/HViktorTsoi/8e8b0468a9fb07842669aa368382a7df)\nTiếp đó chúng ta xử lý nhiễu cho ảnh và làm mịn ảnh để hạn chế những pixel lỗi dùng open CV.\\\n1  cv2.fastNlMeansDenoisingColored(tam,None,10,6,7,21)   Tương tự với phần (1), ta lọc phần khuyết tật bằng phương pháp tượng tự nhưng sẽ được lấy theo mask là $5\\times5$, nghĩa là 1 pixel có tọa độ là $(x,y)$ được xác định là lỗi nếu trên $50%$ pixel thuộc hình vuông có góc trên tọa độ $(x-2,y-2)$ và góc dưới tọa độ $(x+2,y+2)$ là lỗi.\nNgoài ra ta cần phải lấp đầy lỗ trống bên trong mask quả xoài nếu dự đoán bị khuyết phần trong do vấn đề cháy sáng dùng hàm floodfill của openCV:\n1  cv2.floodFill(im\\_flood\\_fill, mask, (0, 0), 255)\\\\   Sau khi đã lọc ra được số lượng pixel của phần khuyết tật ta đem chia với số lượng pixel của quả xoài để ra được tỉ lệ khuyết tật\nThực nghiệm Trong phần này tôi sẽ báo cáo về kết quả thực nghiệm của phương pháp đề xuất trên tập dữ liệu thực tế với data là những quả xoài bị hỏng. Tôi sẽ đánh giá hiệu năng dựa trên toàn bộ quá trình từ giai đoạn 1 đến hết giai đoạn 2.Mô hình này sẽ được đánh giá là tốt nếu như nhận diện đúng và đủ vùng của quả xoài cũng như vùng của những phần khuyết tất và thời gian đáp ứng của hệ thống phải dưới 1 từ quá trình input đến quá trình output. Toàn bộ quá trình được thực hiện trên hệ thống có cấu hình: Intel Core i3 10100f, Ram DDR4 32gb bus 2400Mhz\nNhững điểm tốt Model nhìn chung khá chính xác đối với những background đơn giản như background trắng, phù hợp để đưa vào sử dụng trong công nghiệp với điều kiện điều chỉnh các hằng số cho phù hợp với môi trường hoạt động.\nCó thể dùng model và thuật toán này để sử dụng cho các loại trái cây tương tự như: táo, đu đủ, …\nVới một số background phức tạp, phương pháp này chưa đem lại độ chính xác có thể tin cậy.\nĐộ trễ quá cao và số lượng có thể nhận diện trên 1 giây thấp (xấp xỉ 2) chưa phù hợp với việc áp dụng vô những ngành công nghiệp hoa quả đòi hỏi năng suất cao.\nChưa dự đoán được hình dạng thực tế của quả xoài trong không gian 3 chiều để dự đoán ra diện tích phần khuyết tật một cách chính xác.\nTổng kết Nhìn chung model đã đạt đến độ chính xác cần thiết để áp dụng vào thực tế. Những doanh nghiệp nhỏ và vừa có thể dùng giải pháp này để loại bỏ những quả xoài không mong muốn, tăng chất lượng nông sản một cách tự động, đem đến khách hàng những quả xoài chất lượng nhất. Nhưng không dừng lại ở đó, giải pháp này đòi hỏi có những tinh chỉnh, nâng cấp trực tiếp vào thuật toán xử lý, phải gia tăng chất lượng của thuật toán, giảm thời gian phản hồi cũng như tăng độ chính xác tiệm cận mức tuyệt đối. Ngoài ra giải pháp này cũng cần tăng độ chính xác với những background phức tạp để ứng dụng trong việc chăm sóc xoài tự động, loại bỏ những quả hỏng từ khi còn trên cây.\nMột số hình ảnh sử dụng thực tế của mô hình được tích hợp trong phần mềm camera:\n","date":"2022-08-02T00:00:00Z","image":"https://kpnn0100.github.io/p/nh%E1%BA%ADn-di%E1%BB%87n-ph%E1%BA%A7n-khuy%E1%BA%BFt-t%E1%BA%ADt-c%E1%BB%A7a-xo%C3%A0i-b%E1%BA%B1ng-cnn-v%C3%A0-image-processing/Mango_hu2907c809d45bc33b8d14eaf6680887d3_243174_120x120_fill_box_smart1_3.png","permalink":"https://kpnn0100.github.io/p/nh%E1%BA%ADn-di%E1%BB%87n-ph%E1%BA%A7n-khuy%E1%BA%BFt-t%E1%BA%ADt-c%E1%BB%A7a-xo%C3%A0i-b%E1%BA%B1ng-cnn-v%C3%A0-image-processing/","title":"Nhận diện phần khuyết tật của xoài bằng CNN và Image Processing"},{"content":" A. Các lí thuyết về phản xạ âm thanh I. Phản xạ của âm thanh là gì? Khi âm thanh tiếp xúc một bề mặt bất kì, một phần của nó sẽ được hấp thụ bởi bề mặt vật liệu nó tiếp xúc phần còn lại sẽ được phản xạ trở lại với góc tới bằng góc phản xạ:\nII. Phản xạ này ảnh hưởng như thế nào đến sự “tinh khiết” của nguồn âm? Một số căn phòng cần âm thanh đi từ nguồn âm như (loa, giọng nói,…) đến với tai người một cách chính xác và đầy đủ nhất chẳng hạn như phòng biểu diễn âm nhạc, các studio âm thanh. Chúng ta sẽ muốn hạn chế các vấn đề làm cho âm thanh sai lệch, vấn đề dễ thấy nhất đó chính là phản xạ âm thanh.\nKhi một nguồn âm thanh phát ra tiếng động, 1 luồng âm trực tiếp sẽ đi đến tai người nghe, cùng với đó có những luồng âm thanh phụ sẽ đập vào các vật liệu, các bức tường rồi mới đến tai người nghe. Điều này tạo ra một vấn đề làm cho âm thanh ko còn tinh khiết.\nCác âm thanh phản xạ sẽ có biên độ, màu sắc cũng như thời gian đến tai người nghe khác với âm thanh trực tiếp khiến cho âm thanh gốc ko còn giữ được thông tin gốc ban đầu.\nIII. Hạn chế phản xạ âm thanh Có 2 cách để hạn chế những âm thanh phản xạ:\n1.\tDùng tiêu âm Tiêu âm sẽ làm cho biên độ dao động của âm thanh phản xạ giảm xuống khiến cho tỉ lệ giữa âm thanh phản xạ và âm thanh trực tiếp giảm đi nghĩa là giảm sự sai lệch về cách tiếp nhận của người nghe đối với nguồn âm gốc.\n2.\tDùng tán âm Tán âm sẽ làm âm thanh được dàn đều ra nhiều phía với biên độ dàn đều không tập trung ở một hướng. Dùng tán âm sẽ làm cho các âm thanh phản xạ mờ đi chứ ko chuyển hóa âm thanh thành nhiệt như dùng tiêu âm, điều này vẫn sẽ khiến cho âm thanh gốc sai lệch đi đôi chút nhưng sẽ mềm mịn hơn so với việc phản xạ ko qua xử lí.\nTất nhiên chúng ta sẽ không muốn tiêu âm hoàn toàn, để lại một căn phòng “chết” (không có sự phản xạ âm) nhưng lắp đặt tiêu âm ở vị trí nào sẽ là một bài toán khó khăn nếu mình ko thể biết đường đi của âm thanh.\nVậy ta phải chọn vị trí lắp tiêu âm như thế nào?\nIV. Phương pháp chọn vị trí để tiêu âm cơ bản Trước khi đến với chọn vị trí cần tiêu âm, ta phải xác định, âm thanh nào cần tiêu âm và âm thanh nào có thể bỏ qua.\nCông thức cường độ âm: $$ I = \\frac{P} {4 \\pi R^2 } $$\nTrong đó:\nP: công suất của nguồn âm; R: Khoảng cách từ điểm đang xét tời nguồn âm;\nMẫu số của công thức bên vế phải: Diện tích của hình cầu (Khi âm thanh phát ra thì tất cả mọi điểm bao quanh nguồn âm tạo thành bề mặt của hình cầu)\nTheo công thức trên, ta biết được cường độ âm tỉ lệ nghịch với bình phương khoảng cách từ nguồn âm đến vị trí nghe.\nVậy âm thanh to nhất đối với người nghe chính là âm thanh trực tiếp, âm thanh to thứ nhì là âm thanh của phản xạ đầu (phản xạ chỉ qua 1 bức tường) và tiếp đến là phản xạ 2,3,4…\nChúng ta có thể dễ dàng tính phản xạ đầu bằng cách giải hình học cơ bản, nhưng với phản xạ 2,3,4 rất khó để tính.\nVì vậy các phương pháp chọn vị trí tiêu âm cơ bản sẽ đánh mạnh vào phản xạ đầu.\nV. Những bất cập của phương pháp chỉ tiêu âm phản xạ đầu Các phản xạ 2 và 3 đương nhiên là sẽ có biên độ nhỏ hơn phản xạ đầu nhưng chúng ta chưa khảo sát đến sự chồng chập của nhiều phản xạ.\nSẽ có trường hợp, nhiều phản xạ 2,3 trở đi cùng có nguồn gốc là một vùng tường nhỏ.\nHoặc chúng ta đã xử lý hết các phản xạ đầu, lúc này vẫn chưa đạt được hiệu quả mong muốn thì chúng ta sẽ phải xử lý tiếp những phản xạ tiếp theo.\nB. Reflection Calculator I. Tổng quan dự án Reflection Calculator là một phần mềm minh họa/mô phỏng đường đi của âm thanh trong một căn phòng.\nII. Ý tưởng ban đầu Chúng ta dễ dàng tính được vị trí xảy ra phản xạ đầu nhưng rất khó để có tính toán được chính xác điểm nào xảy ra phản xạ 2,3 và hơn thế nữa.\nVì vậy mình đã có một ý tưởng về việc, giả sử nguồn phát phát đi rất nhiều tia âm thanh, mình sẽ truy vết các tia đó để xem tia nào chạm tới vị trí nghe thì mình sẽ đánh dấu tia đó lại và truy ngược về nơi xảy ra phản xạ đầu tiên của nó, đó là nơi mà mình sẽ tiến hành xử lý tiêu âm\nIII. Khởi tạo Trước khi đến với thuật toán chi tiết thì chúng ta hãy điểm qua những tham số quan trọng ảnh hưởng đến sự minh họa của âm thanh cũng như các yếu tố khác.\nĐầu tiên chính là kích thước phòng: kích thước phòng ảnh hưởng rất nhiều đến hành vi của âm thanh, một căn phòng rộng lớn sẽ có những phản xạ đầu đến rất lâu và biên độ nhỏ hơn nhiều vì quãng được nó đã di chuyển.\nThứ hai chính là vị trí đặt nguồn âm: mỗi vị trí đặt nguồn âm sẽ cho ra các \u0026ldquo;tia\u0026rdquo; âm thanh khác nhau.\nTiếp đó là vị trí nghe: tương tự như vị trí nguồn âm, vị trí nghe khác nhau sẽ đón nhận những âm thanh khác nhau. Ví dụ khi ta ngồi sát tường, âm thanh phản xạ sẽ khác khi chúng ta ngồi giữa phòng.\nVà vì phần mềm này sẽ hoạt động dựa trên việc tạo ra các tia âm thanh nên số lượng tia sẽ ảnh hưởng rất lớn đến độ chính xác. Ít tia thì độ chính xác thấp nhưng hiệu năng cao, nhiều tia thì ngược lại.\nCuối cùng là hệ số hấp thụ của vật liệu: một bức tường sẽ luôn hấp thụ dao động và chuyển hóa thành nhiệt năng nên khi phản xạ một phần âm thanh đã bị tiêu hao đi, đây là một yếu tố cần phải xem xét trước khi đến với tính toán các điểm phản xạ đầu.\nIV. Thuật toán Chúng ta sẽ chia nguồn âm thành [n] tia, mỗi tia lệch nhau 1 góc 2pi/n rad.\nSau đó chúng ta sẽ vẽ đường đi của các tia, mỗi khi chúng tiếp xúc với bề mặt tường chúng ta sẽ cho tia đó phản xạ lại và tiếp tục cho nó di chuyển tiếp cho đến khi độ lớn của âm thanh tiệm cận về mức có thể bỏ qua hoặc tia âm thanh đó đã chạm tới tai người nghe.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108  for (int i = 0; i \u0026lt; count; i++) { double remain = 1; Vector vecto = new Vector(Math.Cos(i*dochia+offset), Math.Sin(i*dochia+offset)); Point start = new Point(sx, sy); Point end = new Point(0, 0); double t1 = (0 - start.Y) / vecto.Y; double t2 = (length - start.Y) / vecto.Y; double t3 = (0 - start.X) / vecto.X; double t4 = (width - start.X) / vecto.X; int j = 0; if (t1 \u0026gt; 0 \u0026amp;\u0026amp; (start.X + t1 * vecto.X) \u0026gt; 0 \u0026amp;\u0026amp; (start.X + t1 * vecto.X) \u0026lt; width) { end = new Point((start.X + t1 * vecto.X), 0); vecto.Y = -vecto.Y; } else if (t2 \u0026gt; 0 \u0026amp;\u0026amp; (start.X + t2 * vecto.X) \u0026gt; 0 \u0026amp;\u0026amp; (start.X + t2 * vecto.X) \u0026lt; width) { end = new Point((start.X + t2 * vecto.X), length); vecto.Y = -vecto.Y; } else if (t3 \u0026gt; 0 \u0026amp;\u0026amp; (start.Y + t3 * vecto.Y) \u0026gt; 0 \u0026amp;\u0026amp; (start.Y + t3 * vecto.Y) \u0026lt; length) { end = new Point(0, (start.Y + t3 * vecto.Y)); vecto.X = -vecto.X; } else if (t4 \u0026gt; 0 \u0026amp;\u0026amp; (start.Y + t4 * vecto.Y) \u0026gt; 0 \u0026amp;\u0026amp; (start.Y + t4 * vecto.Y) \u0026lt; length) { end = new Point(width, (start.Y + t4 * vecto.Y)); vecto.X = -vecto.X; } all[i, j] = linedrawoffset(start.X, start.Y, end.X, end.Y,remain); Point cirpos = end; mainregion.Children.Add(all[i, j]); while (remain \u0026gt; minremain) { j++; remain = remain * (1 - (absort)); start = end; end = new Point(0, 0); t1 = (0 - start.Y) / vecto.Y; t2 = (length - start.Y) / vecto.Y; t3 = (0 - start.X) / vecto.X; t4 = (width - start.X) / vecto.X; end = new Point(0, 0); if (t1 \u0026gt; 0 \u0026amp;\u0026amp; (start.X + t1 * vecto.X) \u0026gt; 0 \u0026amp;\u0026amp; (start.X + t1 * vecto.X) \u0026lt; width) { end = new Point((start.X + t1 * vecto.X), 0); vecto.Y = -vecto.Y; } else if (t2 \u0026gt; 0 \u0026amp;\u0026amp; (start.X + t2 * vecto.X) \u0026gt; 0 \u0026amp;\u0026amp; (start.X + t2 * vecto.X) \u0026lt; width) { end = new Point((start.X + t2 * vecto.X), length); vecto.Y = -vecto.Y; } else if (t3 \u0026gt; 0 \u0026amp;\u0026amp; (start.Y + t3 * vecto.Y) \u0026gt; 0 \u0026amp;\u0026amp; (start.Y + t3 * vecto.Y) \u0026lt; length) { end = new Point(0, (start.Y + t3 * vecto.Y)); vecto.X = -vecto.X; } else if (t4 \u0026gt; 0 \u0026amp;\u0026amp; (start.Y + t4 * vecto.Y) \u0026gt; 0 \u0026amp;\u0026amp; (start.Y + t4 * vecto.Y) \u0026lt; length) { end = new Point(width, (start.Y + t4 * vecto.Y)); vecto.X = -vecto.X; } all[i, j] = linedrawoffset(start.X, start.Y, end.X, end.Y,remain); mainregion.Children.Add(all[i, j]); } int re = j; double mul = 0; bool IsStack = false; double finalabsort = 1; double FarFromMic = 0; Line tam1 = all[i, 0]; mul += Distance2Point(tam1.X1, tam1.Y1, tam1.X2, tam1.Y2); for (int back = 1; back \u0026lt;re+1; back++) { Line tam = all[i, back]; finalabsort *= (1 - absort); double closedistance = distance(mx, my, tam.X2 - tam.X1, tam.Y2 - tam.Y1, tam.X1, tam.Y1); if (closedistance \u0026lt; mindistance) { IsStack = true; mul = mul + Distance2Point(tam.X1, tam.Y1, mx,my); FarFromMic = (1 - closedistance / mindistance); break; } mul += Distance2Point(tam.X1, tam.Y1, tam.X2, tam.Y2); } if (!IsStack) { mul = 0; } else { mul = BaseDistance / mul * finalabsort*FarFromMic; } result[i] = circledrawoffset(cirpos.X,cirpos.Y, mul); mainregion.Children.Add(result[i]); lasttimej = j; }   Với các tia đã thực sự chạm đến người nghe, chúng ta truy ngược về tổng quãng được âm thanh đã di chuyển để tính ra tỉ lệ chênh lệch mức cường độ âm so với âm thanh gốc và nhân với các hệ số hấp thụ của vật liệu.\nTiếp đó vẽ các vòng tròn tại điểm phản xạ đầu của các tia có sự tiếp xúc với vị trí nghe với độ fill bằng với tỉ lệ mức cường độ âm tại điểm tiếp xúc với mức cường độ âm gốc.\nV. Thử nghiệm phần mềm Giả sử chúng ta có một căn phòng có kích thước 4m x 4m, phổ biến với người Việt Nam\nVị trí đặt loa sẽ là 1m, 0.6m\nVị trí người nghe 2m, 2m\nHệ số hấp thụ 0.2\nVà số tia âm thanh là 103 tia (ở đây nên chọn số nguyên tố để có thể đưa ra kết quả sát thực tế nhất)\nNhư hình sau chúng ta nên lắp đặt tiêu âm tại vị trí 1.32m\nC. Kết Luận App này đã thực hiện đúng và đủ ý tưởng ban đầu của mình, nhưng cần cải thiện thêm một số thứ như là như thế nào là một tia âm thanh tiếp xúc với người nghe, các thuật toán nâng cao gia tăng độ chính xác của độ to âm thanh.\nHiện tại các bạn có thể dùng qua phần mềm này tại đây: https://github.com/kpnn0100/ReflectionCalculator\n","date":"2022-08-02T00:00:00Z","image":"https://kpnn0100.github.io/p/reflection-calculator-minh-h%E1%BB%8Da-ph%E1%BA%A3n-x%E1%BA%A1-c%E1%BB%A7a-%C3%A2m-thanh-%C4%91%E1%BB%83-ch%E1%BB%8Dn-v%E1%BB%8B-tr%C3%AD-t%E1%BB%91i-%C6%B0u-hi%E1%BB%87u-qu%E1%BA%A3-c%E1%BB%A7a-acoustic-panel/Reflection%20Calculator_huc2a54fb3e5c964fd44800c7ed552f5ec_384959_120x120_fill_box_smart1_3.png","permalink":"https://kpnn0100.github.io/p/reflection-calculator-minh-h%E1%BB%8Da-ph%E1%BA%A3n-x%E1%BA%A1-c%E1%BB%A7a-%C3%A2m-thanh-%C4%91%E1%BB%83-ch%E1%BB%8Dn-v%E1%BB%8B-tr%C3%AD-t%E1%BB%91i-%C6%B0u-hi%E1%BB%87u-qu%E1%BA%A3-c%E1%BB%A7a-acoustic-panel/","title":"Reflection Calculator: Minh họa phản xạ của âm thanh để chọn vị trí tối ưu hiệu quả của Acoustic Panel"}]