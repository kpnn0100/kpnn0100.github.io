[{"content":" A. Các lí thuyết về phản xạ âm thanh I. Phản xạ của âm thanh là gì? Khi âm thanh tiếp xúc một bề mặt bất kì, một phần của nó sẽ được hấp thụ bởi bề mặt vật liệu nó tiếp xúc phần còn lại sẽ được phản xạ trở lại với góc tới bằng góc phản xạ:\nII. Phản xạ này ảnh hưởng như thế nào đến sự “tinh khiết” của nguồn âm? Một số căn phòng cần âm thanh đi từ nguồn âm như (loa, giọng nói,…) đến với tai người một cách chính xác và đầy đủ nhất chẳng hạn như phòng biểu diễn âm nhạc, các studio âm thanh. Chúng ta sẽ muốn hạn chế các vấn đề làm cho âm thanh sai lệch, vấn đề dễ thấy nhất đó chính là phản xạ âm thanh.\nKhi một nguồn âm thanh phát ra tiếng động, 1 luồng âm trực tiếp sẽ đi đến tai người nghe, cùng với đó có những luồng âm thanh phụ sẽ đập vào các vật liệu, các bức tường rồi mới đến tai người nghe. Điều này tạo ra một vấn đề làm cho âm thanh ko còn tinh khiết.\nCác âm thanh phản xạ sẽ có biên độ, màu sắc cũng như thời gian đến tai người nghe khác với âm thanh trực tiếp khiến cho âm thanh gốc ko còn giữ được thông tin gốc ban đầu.\nIII. Hạn chế phản xạ âm thanh Có 2 cách để hạn chế những âm thanh phản xạ:\n1.\tDùng tiêu âm Tiêu âm sẽ làm cho biên độ dao động của âm thanh phản xạ giảm xuống khiến cho tỉ lệ giữa âm thanh phản xạ và âm thanh trực tiếp giảm đi nghĩa là giảm sự sai lệch về cách tiếp nhận của người nghe đối với nguồn âm gốc.\n2.\tDùng tán âm Tán âm sẽ làm âm thanh được dàn đều ra nhiều phía với biên độ dàn đều không tập trung ở một hướng. Dùng tán âm sẽ làm cho các âm thanh phản xạ mờ đi chứ ko chuyển hóa âm thanh thành nhiệt như dùng tiêu âm, điều này vẫn sẽ khiến cho âm thanh gốc sai lệch đi đôi chút nhưng sẽ mềm mịn hơn so với việc phản xạ ko qua xử lí.\nTất nhiên chúng ta sẽ không muốn tiêu âm hoàn toàn, để lại một căn phòng “chết” (không có sự phản xạ âm) nhưng lắp đặt tiêu âm ở vị trí nào sẽ là một bài toán khó khăn nếu mình ko thể biết đường đi của âm thanh.\nVậy ta phải chọn vị trí lắp tiêu âm như thế nào?\nIV. Phương pháp chọn vị trí để tiêu âm cơ bản Trước khi đến với chọn vị trí cần tiêu âm, ta phải xác định, âm thanh nào cần tiêu âm và âm thanh nào có thể bỏ qua.\nCông thức cường độ âm: $$ I = \\frac{P} {4 \\pi R^2 } $$\nTrong đó:\nP: công suất của nguồn âm; R: Khoảng cách từ điểm đang xét tời nguồn âm;\nMẫu số của công thức bên vế phải: Diện tích của hình cầu (Khi âm thanh phát ra thì tất cả mọi điểm bao quanh nguồn âm tạo thành bề mặt của hình cầu)\nTheo công thức trên, ta biết được cường độ âm tỉ lệ nghịch với bình phương khoảng cách từ nguồn âm đến vị trí nghe.\nVậy âm thanh to nhất đối với người nghe chính là âm thanh trực tiếp, âm thanh to thứ nhì là âm thanh của phản xạ đầu (phản xạ chỉ qua 1 bức tường) và tiếp đến là phản xạ 2,3,4…\nChúng ta có thể dễ dàng tính phản xạ đầu bằng cách giải hình học cơ bản, nhưng với phản xạ 2,3,4 rất khó để tính.\nVì vậy các phương pháp chọn vị trí tiêu âm cơ bản sẽ đánh mạnh vào phản xạ đầu.\nV. Những bất cập của phương pháp chỉ tiêu âm phản xạ đầu Các phản xạ 2 và 3 đương nhiên là sẽ có biên độ nhỏ hơn phản xạ đầu nhưng chúng ta chưa khảo sát đến sự chồng chập của nhiều phản xạ.\nSẽ có trường hợp, nhiều phản xạ 2,3 trở đi cùng có nguồn gốc là một vùng tường nhỏ.\nHoặc chúng ta đã xử lý hết các phản xạ đầu, lúc này vẫn chưa đạt được hiệu quả mong muốn thì chúng ta sẽ phải xử lý tiếp những phản xạ tiếp theo.\nB. Reflection Calculator I. Tổng quan dự án Reflection Calculator là một phần mềm minh họa/mô phỏng đường đi của âm thanh trong một căn phòng.\nII. Ý tưởng ban đầu Chúng ta dễ dàng tính được vị trí xảy ra phản xạ đầu nhưng rất khó để có tính toán được chính xác điểm nào xảy ra phản xạ 2,3 và hơn thế nữa.\nVì vậy mình đã có một ý tưởng về việc, giả sử nguồn phát phát đi rất nhiều tia âm thanh, mình sẽ truy vết các tia đó để xem tia nào chạm tới vị trí nghe thì mình sẽ đánh dấu tia đó lại và truy ngược về nơi xảy ra phản xạ đầu tiên của nó, đó là nơi mà mình sẽ tiến hành xử lý tiêu âm\nIII. Khởi tạo Trước khi đến với thuật toán chi tiết thì chúng ta hãy điểm qua những tham số quan trọng ảnh hưởng đến sự minh họa của âm thanh cũng như các yếu tố khác.\nĐầu tiên chính là kích thước phòng: kích thước phòng ảnh hưởng rất nhiều đến hành vi của âm thanh, một căn phòng rộng lớn sẽ có những phản xạ đầu đến rất lâu và biên độ nhỏ hơn nhiều vì quãng được nó đã di chuyển.\nThứ hai chính là vị trí đặt nguồn âm: mỗi vị trí đặt nguồn âm sẽ cho ra các \u0026ldquo;tia\u0026rdquo; âm thanh khác nhau.\nTiếp đó là vị trí nghe: tương tự như vị trí nguồn âm, vị trí nghe khác nhau sẽ đón nhận những âm thanh khác nhau. Ví dụ khi ta ngồi sát tường, âm thanh phản xạ sẽ khác khi chúng ta ngồi giữa phòng.\nVà vì phần mềm này sẽ hoạt động dựa trên việc tạo ra các tia âm thanh nên số lượng tia sẽ ảnh hưởng rất lớn đến độ chính xác. Ít tia thì độ chính xác thấp nhưng hiệu năng cao, nhiều tia thì ngược lại.\nCuối cùng là hệ số hấp thụ của vật liệu: một bức tường sẽ luôn hấp thụ dao động và chuyển hóa thành nhiệt năng nên khi phản xạ một phần âm thanh đã bị tiêu hao đi, đây là một yếu tố cần phải xem xét trước khi đến với tính toán các điểm phản xạ đầu.\nIV. Thuật toán Chúng ta sẽ chia nguồn âm thành [n] tia, mỗi tia lệch nhau 1 góc 2pi/n rad.\nSau đó chúng ta sẽ vẽ đường đi của các tia, mỗi khi chúng tiếp xúc với bề mặt tường chúng ta sẽ cho tia đó phản xạ lại và tiếp tục cho nó di chuyển tiếp cho đến khi độ lớn của âm thanh tiệm cận về mức có thể bỏ qua hoặc tia âm thanh đó đã chạm tới tai người nghe.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108  for (int i = 0; i \u0026lt; count; i++) { double remain = 1; Vector vecto = new Vector(Math.Cos(i*dochia+offset), Math.Sin(i*dochia+offset)); Point start = new Point(sx, sy); Point end = new Point(0, 0); double t1 = (0 - start.Y) / vecto.Y; double t2 = (length - start.Y) / vecto.Y; double t3 = (0 - start.X) / vecto.X; double t4 = (width - start.X) / vecto.X; int j = 0; if (t1 \u0026gt; 0 \u0026amp;\u0026amp; (start.X + t1 * vecto.X) \u0026gt; 0 \u0026amp;\u0026amp; (start.X + t1 * vecto.X) \u0026lt; width) { end = new Point((start.X + t1 * vecto.X), 0); vecto.Y = -vecto.Y; } else if (t2 \u0026gt; 0 \u0026amp;\u0026amp; (start.X + t2 * vecto.X) \u0026gt; 0 \u0026amp;\u0026amp; (start.X + t2 * vecto.X) \u0026lt; width) { end = new Point((start.X + t2 * vecto.X), length); vecto.Y = -vecto.Y; } else if (t3 \u0026gt; 0 \u0026amp;\u0026amp; (start.Y + t3 * vecto.Y) \u0026gt; 0 \u0026amp;\u0026amp; (start.Y + t3 * vecto.Y) \u0026lt; length) { end = new Point(0, (start.Y + t3 * vecto.Y)); vecto.X = -vecto.X; } else if (t4 \u0026gt; 0 \u0026amp;\u0026amp; (start.Y + t4 * vecto.Y) \u0026gt; 0 \u0026amp;\u0026amp; (start.Y + t4 * vecto.Y) \u0026lt; length) { end = new Point(width, (start.Y + t4 * vecto.Y)); vecto.X = -vecto.X; } all[i, j] = linedrawoffset(start.X, start.Y, end.X, end.Y,remain); Point cirpos = end; mainregion.Children.Add(all[i, j]); while (remain \u0026gt; minremain) { j++; remain = remain * (1 - (absort)); start = end; end = new Point(0, 0); t1 = (0 - start.Y) / vecto.Y; t2 = (length - start.Y) / vecto.Y; t3 = (0 - start.X) / vecto.X; t4 = (width - start.X) / vecto.X; end = new Point(0, 0); if (t1 \u0026gt; 0 \u0026amp;\u0026amp; (start.X + t1 * vecto.X) \u0026gt; 0 \u0026amp;\u0026amp; (start.X + t1 * vecto.X) \u0026lt; width) { end = new Point((start.X + t1 * vecto.X), 0); vecto.Y = -vecto.Y; } else if (t2 \u0026gt; 0 \u0026amp;\u0026amp; (start.X + t2 * vecto.X) \u0026gt; 0 \u0026amp;\u0026amp; (start.X + t2 * vecto.X) \u0026lt; width) { end = new Point((start.X + t2 * vecto.X), length); vecto.Y = -vecto.Y; } else if (t3 \u0026gt; 0 \u0026amp;\u0026amp; (start.Y + t3 * vecto.Y) \u0026gt; 0 \u0026amp;\u0026amp; (start.Y + t3 * vecto.Y) \u0026lt; length) { end = new Point(0, (start.Y + t3 * vecto.Y)); vecto.X = -vecto.X; } else if (t4 \u0026gt; 0 \u0026amp;\u0026amp; (start.Y + t4 * vecto.Y) \u0026gt; 0 \u0026amp;\u0026amp; (start.Y + t4 * vecto.Y) \u0026lt; length) { end = new Point(width, (start.Y + t4 * vecto.Y)); vecto.X = -vecto.X; } all[i, j] = linedrawoffset(start.X, start.Y, end.X, end.Y,remain); mainregion.Children.Add(all[i, j]); } int re = j; double mul = 0; bool IsStack = false; double finalabsort = 1; double FarFromMic = 0; Line tam1 = all[i, 0]; mul += Distance2Point(tam1.X1, tam1.Y1, tam1.X2, tam1.Y2); for (int back = 1; back \u0026lt;re+1; back++) { Line tam = all[i, back]; finalabsort *= (1 - absort); double closedistance = distance(mx, my, tam.X2 - tam.X1, tam.Y2 - tam.Y1, tam.X1, tam.Y1); if (closedistance \u0026lt; mindistance) { IsStack = true; mul = mul + Distance2Point(tam.X1, tam.Y1, mx,my); FarFromMic = (1 - closedistance / mindistance); break; } mul += Distance2Point(tam.X1, tam.Y1, tam.X2, tam.Y2); } if (!IsStack) { mul = 0; } else { mul = BaseDistance / mul * finalabsort*FarFromMic; } result[i] = circledrawoffset(cirpos.X,cirpos.Y, mul); mainregion.Children.Add(result[i]); lasttimej = j; }   Với các tia đã thực sự chạm đến người nghe, chúng ta truy ngược về tổng quãng được âm thanh đã di chuyển để tính ra tỉ lệ chênh lệch mức cường độ âm so với âm thanh gốc và nhân với các hệ số hấp thụ của vật liệu.\nTiếp đó vẽ các vòng tròn tại điểm phản xạ đầu của các tia có sự tiếp xúc với vị trí nghe với độ fill bằng với tỉ lệ mức cường độ âm tại điểm tiếp xúc với mức cường độ âm gốc.\nV. Thử nghiệm phần mềm Giả sử chúng ta có một căn phòng có kích thước 4m x 4m, phổ biến với người Việt Nam\nVị trí đặt loa sẽ là 1m, 0.6m\nVị trí người nghe 2m, 2m\nHệ số hấp thụ 0.2\nVà số tia âm thanh là 103 tia (ở đây nên chọn số nguyên tố để có thể đưa ra kết quả sát thực tế nhất)\nNhư hình sau chúng ta nên lắp đặt tiêu âm tại vị trí 1.32m\nC. Kết Luận App này đã thực hiện đúng và đủ ý tưởng ban đầu của mình, nhưng cần cải thiện thêm một số thứ như là như thế nào là một tia âm thanh tiếp xúc với người nghe, các thuật toán nâng cao gia tăng độ chính xác của độ to âm thanh.\nHiện tại các bạn có thể dùng qua phần mềm này tại đây: https://github.com/kpnn0100/ReflectionCalculator\n","date":"2022-08-03T00:00:00Z","image":"https://kpnn0100.github.io/p/reflection-calculator-minh-h%E1%BB%8Da-ph%E1%BA%A3n-x%E1%BA%A1-c%E1%BB%A7a-%C3%A2m-thanh-%C4%91%E1%BB%83-ch%E1%BB%8Dn-v%E1%BB%8B-tr%C3%AD-t%E1%BB%91i-%C6%B0u-hi%E1%BB%87u-qu%E1%BA%A3-c%E1%BB%A7a-acoustic-panel/Reflection%20Calculator_huc2a54fb3e5c964fd44800c7ed552f5ec_384959_120x120_fill_box_smart1_3.png","permalink":"https://kpnn0100.github.io/p/reflection-calculator-minh-h%E1%BB%8Da-ph%E1%BA%A3n-x%E1%BA%A1-c%E1%BB%A7a-%C3%A2m-thanh-%C4%91%E1%BB%83-ch%E1%BB%8Dn-v%E1%BB%8B-tr%C3%AD-t%E1%BB%91i-%C6%B0u-hi%E1%BB%87u-qu%E1%BA%A3-c%E1%BB%A7a-acoustic-panel/","title":"Reflection Calculator: Minh họa phản xạ của âm thanh để chọn vị trí tối ưu hiệu quả của Acoustic Panel"},{"content":" A. Các lý thuyết Trước khi đến với plugin của mình, chúng ta cần hiểu các khái niệm vật lý cơ bản để rõ hơn tác dụng của plugin này.\nI. Cách chúng ta định hướng âm thanh 1. Interaural Time Difference/Chênh lệch thời gian tiếp nhận Chúng ta có 2 tai, được đặt ở 2 vị trí cách nhau. Điều này khiến cho cách chúng ta tiếp nhận một nguồn âm là khác nhau ở mỗi bên tai.\nVới các nguồn âm ở bên phải chúng ta, tai phải sẽ tiếp nhận dao động âm thanh sớm hơn so với tai trái. Điều ngược lại sẽ xảy ra với các nguồn âm bên trái.\nĐộ chênh lệch đó có thể được diễn giải bằng phương trình sau:\n$$ \\Delta t = \\frac{|d_l-d_r|}{c} $$\ntrong đó\n$d_l$ : khoảng cách từ nguồn âm đến tai trái\n$d_r$ : khoảng cách từ nguồn âm đến tai phải\n$c$ : hằng số tốc độ âm thanh trong môi trường, $c = 343 \\frac{m}{s}$ trong điều kiện tự nhiên\n2. Interaural Level Difference/Chênh lệch âm lượng tiếp nhận Nhờ vào cấu tạo đầu của chúng ta và vị trí phân bổ 2 tai, các vùng bị che khuất bởi đầu của mình sẽ có chênh lệch về biên độ dao động, một phần dao động từ nguồn âm đã bị đầu chúng ta \u0026ldquo;ăn\u0026rdquo; mất. Chúng ta sẽ cùng xem hình sau để dễ hình dung về cả 2 sự chênh lệch này.\n3. Stimulus Spectrum/Sự thay đổi về tần số Hãy đặt trước mặt 1 nguồn phát âm thanh, có thể là một cái loa hay một cái quạt. Từ từ cúi đầu xuống và ngửa đầu lên trong khi cổ vẫn hướng về phía nguồn âm, ta sẽ thấy được một sự khác biệt ko đến từ việc chênh lệch tiếp nhận giữa 2 bên tai mà đến từ chính âm sắc của nguồn âm.\nCấu tạo của tai rất phức tạp dẫn đến các cộng hưởng về tần số của âm thanh sẽ khác nhau đối với các hướng tiếp nhận âm thanh khác nhau.\nĐối với các nguồn âm trước mặt, âm thanh dường như có vẻ rõ nét hơn.\nII. Đường đi của âm thanh trong căn phòng Các bạn có thể đọc bài viết của mình về dự án \u0026ldquo;Reflection Calculator\u0026rdquo; để hiểu rõ hơn vấn đề này. Ở đây mình sẽ chỉ tóm tắt.\n1. Sự phản xạ âm Ngoài âm thanh trực tiếp đi đến tai, chúng ta còn có các nguồn âm phụ được tạo ra bởi chính nguồn âm chính, có thời gian đến tai mình cũng như biên độ khác với nguồn âm chính.\n2. Sự định hướng của phản xạ âm Và cũng không ngoại lệ, những âm thanh phản xạ cũng có các đặc tính giống như nguồn âm gốc ban đầu, qua đó chúng ta có thể xác định được âm thanh phản xạ ở vị trí nào.\nVới một căn phòng hình dạng bình thường, chúng ta sẽ có 6 phản xạ đầu có âm lượng lớn nhất đến từ 6 mặt của căn phòng.\nVà các phản xạ sau đó, chúng ta có thể coi như đó là âm vang (reverb)\nB. True Position - Một plugin được phát triển bởi mình I. Tại sao mình làm plugin này Bản thân mình là một người viết nhạc, một người hòa âm và một người phối khí. Trong quá trình sáng tác, hoàn thiện các tác phẩm âm nhạc, mình nhận ra một thao tác mình lặp lại rất nhiều lần nhưng ko đạt được độ hiệu quả cao do mình ko có đủ thời gian để tập trung vào một vấn đề quá nhiều.\nVấn đề đó chính là tạo không gian cho âm thanh. Một cây guitar ở bên trái 30 độ, một cây violin ở bên phải 45 độ hay một cây piano ở trước mặt mình. Cách nhanh nhất và phổ biến nhất mọi người hay dùng để tạo ra không gian trong âm thanh chính là lệch đi biên độ dao động của 2 bên tai, tạo ra một sự chênh lệch 2 bên tai cho 1 nguồn âm.\nNhưng cách này lại không đem đến được sự chính xác, nhất là khi nguồn âm di chuyển, chúng ta có thể nhận ra rõ ràng vấn đề của phương pháp này, âm thanh có vẻ như đang đi xuyên qua đầu mình, chứ ko phải đi ngang qua trước mặt như cách mà nó phải xảy ra. Hãy thử tưởng tượng một ca sĩ đi xuyên qua đầu mình, chỉ nghĩ đến thôi đã thấy rợn người.\nCách mình hay sử dụng đó là dùng một plugin khác có sẵn hoặc dùng chính các tính năng của DAW để tạo ra sự chênh lệch về thời gian của âm thanh, kết hợp với chênh lệch về biên độ để tạo ra một không gian chính xác nhất.\nNHƯNG\nTất nhiên là sẽ có một bất cập nào đấy khiến mình phải bỏ công viết plugin này. Bỏ qua các yếu tố cá nhân như muốn thể hiện bản thân ở lĩnh vực này. Rất khó để có thể kiểm soát những thành phần của bản nhạc chỉ việc thay đổi chênh lệch về thời gian, khi số lượng nhạc cụ đã đạt tới con số 10 15, mình không thể biết được cây piano đầu tiên mình đã đặt nó ở vị trí nào, chỉ dùng tai để nghe không thể xác định chính xác được. Điều này có thể gây nên những xung đột về không gian, chẳng hạn như guitar và vocal bè ở chung 1 vị trí (Nếu điều này xảy ra trong thực tế nghĩa là vocal bè ngồi lên đầu guitar :\u0026gt; rất là dị), nhưng rất khó để xác định được vấn đề đến từ 2 cái thằng này vì giới hạn của tai người.\n  Ngoài ra, rất là phức tạp để có thể tạo được thông số delay đúng với thực tế ở trong 1 căn phòng, gần như cách mình sử dụng chỉ là chọn thời gian chênh lệch giữa các lần delay bằng với một phách hay nửa phách, để cho dù nó có sai với thực tế thì nó vẫn phù hợp với tính nhạc. Vì thế mình quyết định viết 1 cái plugin có giao diện trực quan để kiểm soát những thành phần này tốt hơn.\nII. Ý tưởng ban đầu \u0026ldquo;Nó sẽ chỉ cần 1 cái kéo thả tương ứng với vị trí nguồn phát\u0026rdquo; - mình nghĩ\nGiao diện đó phải là một cái gì đấy khác với các plugin thông thường, nơi mà mọi thứ được thể hiện bằng số giống với các đồ analog ngày xưa. Giao diện đó phải trực quan và dễ sử dụng, càng ít sự tương tác càng tốt, nhưng ko được bỏ qua những thông số quan trọng.\nXong phần giao diện, thuật toán là cái rất quan trọng với 1 plugin, một thuật toán dở có thể làm plugin bị trôi vào dĩ vãng. Làm sao để tạo ra sự chênh lệch về thời gian?\nPhải chăng chỉ cần giữ lại những sample của quá khứ và phát nó lại ở một thời điểm mình đã tính ra được dựa vào những công thức vốn có thì chúng ta sẽ có một phần trình diễn hoàn hảo đến từ các con số thập phân dấu phẩy động.\nNhưng không đơn giản vậy, hiệu năng là một thứ rất đáng lưu ý đối với real time digital signal processing (Xử lý tín hiệu thời gian thực).\nLàm sao để chúng ta có thể liên tục ghi những sample mới đồng thời biết chính xác địa chỉ cần truy cập của sample cũ. Việc giữ cho mảng của chúng ta luôn có sample mới nhất nằm ở phần từ 0 của mảng sẽ rất tốn hiệu năng của máy tính vì nó phải liên tục làm mới mảng để đưa ra được vị trí đúng cho từng phần tử.\nMột giải pháp đó chính là mảng liên kết, bằng cách liên tục chèn phần tử mới vào đầu mảng, chúng ta sẽ luôn có một thứ tự đúng của mỗi phần tử, phần tử đầu tiên là sample vừa mới được tiếp nhận, và phần tử cuối cùng là phần tử \u0026ldquo;già\u0026rdquo; nhất của mảng.\nvẫn là một cái NHƯNG\nViệc truy cập vào một phần tử cụ thể xảy ra liên tục nên dùng mảng liên kết sẽ ko thể tối ưu được chuyện này vì muốn truy cập vào phần tử của mảng liên kết, bắt buộc phải duyệt qua từng phần tử cho đến phần tử cần tìm. Hàng trăm, hàng nghìn lệnh so sánh ko cần thiết sẽ là một thất bại cho dự án này.\nVậy thì kết hợp 2 cái lại\nChúng ta tạo ra mảng liên kết của riêng mình. Bằng cách dùng 1 biến để lưu giá trị tương ứng với địa chỉ của phần tử đầu chúng ta có thể thích nghi được với sự làm mới liên tục của dữ liệu âm thanh.\nChúng ta sẽ cùng lúc, ghi đè dữ liệu mới vào địa chỉ mà chúng ta đang đánh dấu là địa chỉ của cái đầu và cập nhật địa chỉ tiếp theo. Điều này đỏi hỏi số lượng phần tử của mảng phải là một hằng số\n1 2 3 4 5 6 7 8  for (int sample = 0; sample \u0026lt; numSamples; sample++) { PastSample[head] = bufferLChannel[sample]; head += 1; if (head == maxdelaysample) { head = 0; } }   Đã có được sự chênh lệch về âm thanh cơ bản, chúng ta sẽ tạo ra chênh lệch về biên độ. Điều này thậm chí còn đơn giản hơn khi mà chỉ cần cho rằng chênh lệch biên độ tỉ lệ thuận với chênh lệch thời gian.\nVà ta đã xong phần định hướng âm, vậy còn phần tạo ra các phản xạ âm trong phòng.\nVẫn rất là đơn giản, chúng ta sẽ sử dụng hình học cơ bản để tìm ra các điểm phản xạ âm mà tiếp xúc đến tai người nghe.\nIII. Thực nghiệm Đây là giao diện sử dụng của plugin:\nChấm màu đen là vị trí của người nghe\nChấm trắng có thể kéo thả, là vị trí của nguồn phát sẽ liên kết với slider Position X, Position Y\nRoom Length: kích thước phòng theo chiều ngang\nRoom Width: kích thước phòng theo chiều dọc\nRoom Heigh: kích thước phòng theo chiều cao\nDry: Độ lớn của âm thanh trực tiếp\nWet: độ lớn của những âm thanh phản xạ\nHãy cùng so sánh phương pháp thông thường và phương pháp sử dụng plugin của mình (Nhớ đeo tai nghe nhé)\nCách panning thông thường:\n  Dùng plugin của mình vặn tham số x:\n  Hiện tại các bạn có thể dùng thử phiên bản đầu tiên của Plugin này tại đây:\nhttps://github.com/kpnn0100/TruePosition\n","date":"2022-08-03T00:00:00Z","permalink":"https://kpnn0100.github.io/p/true-position-vst3-plugin-gi%E1%BA%A3-l%E1%BA%ADp-v%E1%BB%8B-tr%C3%AD-%C3%A2m-thanh-trong-ph%C3%B2ng/","title":"True Position: VST3 Plugin giả lập vị trí âm thanh trong phòng"}]